
using System;
using System.Collections.Generic;
using System.Data;
using System.Globalization;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.IO;
using DynamicData.Kernel;
using Mutagen.Bethesda;
using Mutagen.Bethesda.FormKeys.SkyrimSE;
using Mutagen.Bethesda.Plugins;
using Mutagen.Bethesda.Skyrim;
using Mutagen.Bethesda.Synthesis;
using Noggog;
using System.Text.RegularExpressions;
using System.Reflection;
using System.Reflection.Metadata;
using CommandLine;
using System.Linq;
using Mutagen.Bethesda;
using Mutagen.Bethesda.Plugins.Records;
using Mutagen.Bethesda.Skyrim;
using ScriptProperty = Mutagen.Bethesda.Skyrim.ScriptProperty;
using VirtualMachineAdapter = Mutagen.Bethesda.Skyrim.VirtualMachineAdapter;
using IQuest = Mutagen.Bethesda.Skyrim.IQuest;
using System.Collections;
using DynamicData;
using Newtonsoft.Json;


// Function to initialize the matches dictionary with all keys set to 0


namespace unofficialReqtificatorLite;

public class Program
{
    private static Lazy<Settings> formSettings = null!;

    static void WriteToIniFile(string filePath, string text)
    {
        // Open the file for appending
        using (StreamWriter writer = new StreamWriter(filePath, true, Encoding.UTF8))
        {
            // Write the text to the file
            writer.WriteLine(text);
        }
    }
    static void ClearFile(string filePath)
    {
        // Open the file for writing and clear its content
        using (StreamWriter writer = new StreamWriter(filePath, false, Encoding.UTF8))
        {
            // Write nothing to the file (effectively clearing its content)
        }
    }
    static DataTable CreateDataTableFromCsv(string filePath)
    {
        DataTable dataTable = new DataTable();

        // Read all lines from the CSV file
        string[] lines = File.ReadAllLines(filePath);

        if (lines.Length > 0)
        {
            // Determine the number of columns based on the first line
            string[] firstLineValues = lines[0].Split(',');

            // Add generic column names (Column1, Column2, etc.)
            for (int col = 0; col < firstLineValues.Length; col++)
            {
                dataTable.Columns.Add("Column" + (col + 1));
            }

            // Add all rows starting from the first line
            foreach (string line in lines)
            {
                string[] values = line.Split(',');
                dataTable.Rows.Add(values);
            }
        }

        return dataTable;
    }


    public static Task<int> Main(string[] args)
    {
        return SynthesisPipeline.Instance
            .AddPatch<ISkyrimMod, ISkyrimModGetter>(RunPatch)
            .SetAutogeneratedSettings(
                "Settings",
                "Settings.json",
                out formSettings)
            .SetTypicalOpen(GameRelease.SkyrimSE, "unofficialReqtificatorLite.esp")
            .Run(args);
    }
    
    public static void RunPatch(IPatcherState<ISkyrimMod, ISkyrimModGetter> state)
    {
        var npcGroups = state.LoadOrder.PriorityOrder.Reverse()
            .Select(listing => listing.Mod)
            .NotNull()
            .Select(x => (x.ModKey, x.Npcs))
            .Where(x => formSettings.Value.TargetMods.Contains(x.ModKey))
            .ToArray();
        if (formSettings.Value.ReqOn || formSettings.Value.txtOn)
        {
            Console.WriteLine("Patcher Mode: Automatic");
        }
        else
        {
            Console.WriteLine("Patching the Selected Plugins:");
            foreach (var modKey in npcGroups.Select(x => x.ModKey))
            {
                Console.WriteLine($"  {modKey}");

            }
        }

    
        bool fozar = state.LoadOrder.PriorityOrder.Reverse().ModExists("Fozars_Dragonborn_ - _Requiem_Patch.esp");
        bool MagicRedone = state.LoadOrder.PriorityOrder.Reverse().ModExists("Requiem - Magic Redone.esp");
        bool WeapRedone = state.LoadOrder.PriorityOrder.Reverse().ModExists("Requiem - Weapons and Armor Redone.esp");

        FormKey formkeyActor = FormKey.Factory("000800:RFTI_Alternative_Keyword.esp");
        FormKey formkeyArmo = FormKey.Factory("000801:RFTI_Alternative_Keyword.esp");
        FormKey  formkeyWeap = FormKey.Factory("000802:RFTI_Alternative_Keyword.esp");
        FormKey formKeyPatched = FormKey.Factory("000803:RFTI_Alternative_Keyword.esp");
        FormKey noDamgeRescale = FormKey.Factory("AD3B2D:Requiem.esp");
        FormKey noArmorRescale = FormKey.Factory("AD3B2B:Requiem.esp");
        FormKey noWeaponReach = FormKey.Factory("AD3B2E:Requiem.esp");
        FormKey NoBowSpeedRescale = FormKey.Factory("AD3B2F:Requiem.esp");

      


        //public readonly Mutagen.Bethesda.Skyrim.ScriptEntry _lockPickingScript;
        var lockPickingControScript = new Mutagen.Bethesda.Skyrim.ScriptEntry
        {
            Name = "REQ_LockpickControl"
        };

        var FormKeyReqQuest = new FormLink<IQuestGetter>(FormKey.Factory("AD3B22:Requiem.esp"));
        lockPickingControScript.Properties.Add(new Mutagen.Bethesda.Skyrim.ScriptObjectProperty()
        {
            Name = "dataStorage",
            Alias = 18,
            Object = FormKeyReqQuest,
            Flags = ScriptProperty.Flag.Edited
        });
        //1182F3AF
        var FormKeyReqQuest2 = new FormLink<IQuestGetter>(FormKey.Factory("82F3AF:Requiem.esp"));
        lockPickingControScript.Properties.Add(new Mutagen.Bethesda.Skyrim.ScriptObjectProperty()
        {
            Name = "FollowerControl",
            Object = FormKeyReqQuest2,
            Flags = ScriptProperty.Flag.Edited
        });

        
        //Console.WriteLine(mod);
       
        List<string> masterList = new List<string>();
        // Initialize the ignoreList with non-nullable string type to match RFTImasterList
        List<string> ignoreList = new List<string>();

        // Define the path to the file
        string outputPath = $@"{state.DataFolderPath}\ReqLite_IgnoreThesePlugins.txt";

        string reqPerksAll = $@"{state.DataFolderPath}\RFTIL_perks_all.txt";
 if (!File.Exists(reqPerksAll))
 {
     Console.WriteLine("ERROR ERROR ERROR ERROR");
     Console.WriteLine("ERROR ERROR ERROR ERROR");
     Console.WriteLine("ERROR ERROR ERROR ERROR");
     Console.WriteLine("Necessary .txt files not found. Please go to the nexus page and download and install the newest Version.");
Console.WriteLine("Necessary .txt files not found. Please go to the nexus page and download and install the newest Version.");
Console.WriteLine("Necessary .txt files not found. Please go to the nexus page and download and install the newest Version.");
 }

        string reqSpellsAll = $@"{state.DataFolderPath}\RFTIL_spells_all.txt";
        string reqSpellsRaces = $@"{state.DataFolderPath}\RFTIL_spells_races.txt";
        string reqSpellsRaces_Fozar = $@"{state.DataFolderPath}\RFTIL_spells_races_fozar.txt";
        string reqPerksRaces = $@"{state.DataFolderPath}\RFTIL_perks_races.txt";
        string reqPerksRaces_Fozar = $@"{state.DataFolderPath}\RFTIL_perks_races_fozar.txt";
        string reqPerksAll_MR = $@"{state.DataFolderPath}\RFTIL_perks_all_magic_redone.txt";
        string reqKeysArmor = $@"{state.DataFolderPath}\RFTIL_armor_keywords.txt";
        string reqKeysArmorBody = $@"{state.DataFolderPath}\RFTIL_armor_keywords_body.txt";
        string reqKeysWeapons = $@"{state.DataFolderPath}\RFTIL_weapon_keywords.txt";

        DataTable DB_reqPerksAll = CreateDataTableFromCsv(reqPerksAll);
        DataTable DB_reqSpellsAll = CreateDataTableFromCsv(reqSpellsAll);
        DataTable DB_reqSpellsRaces = CreateDataTableFromCsv(reqSpellsRaces);
        DataTable DB_reqSpellsRaces_Fozar = CreateDataTableFromCsv(reqSpellsRaces_Fozar);
        DataTable DB_reqPerksAll_MR = CreateDataTableFromCsv(reqPerksAll_MR);
        DataTable DB_reqKeysArmor = CreateDataTableFromCsv(reqKeysArmor);
        DataTable DB_reqKeysArmorBody = CreateDataTableFromCsv(reqKeysArmorBody);
        DataTable DB_reqKeysWeapons = CreateDataTableFromCsv(reqKeysWeapons);
        DataTable DB_reqPerksRaces = CreateDataTableFromCsv(reqPerksRaces);
        DataTable DB_reqPerksRaces_Fozar = CreateDataTableFromCsv(reqPerksRaces_Fozar);


        // Check if the file exists and read it into ignoreList, else create it
        if (File.Exists(outputPath))
        {
            // Read all lines ensuring they are non-null strings
            ignoreList = File.ReadAllLines(outputPath).Where(line => line != null).ToList();
        }
        else
        {
            // Initialize an empty file to avoid null issues later
            WriteToIniFile(outputPath, "");
        }
        // Initialize RFTImasterList as an empty list
        var RFTImasterList = new List<string>();
        try
        {
            var mod = state.LoadOrder.TryGetValue("Requiem for the Indifferent.esp");
            // Check if masters are null before accessing them
            var masters = mod?.Mod?.ModHeader.MasterReferences;
            // Use a for loop to add each master's ToString() result to RFTImasterList
            if (masters != null)
            {
                for (int i = 0; i < masters.Count; i++)
                {

                    RFTImasterList.Add(masters[i]?.Master.FileName.ToString() ?? string.Empty);
                }
            }
        }
        catch
        {

        }
        
      

        // If formSettings.Value.txtOn is true, assign ignoreList to RFTImasterList
        if (formSettings.Value.txtOn)
        {
            RFTImasterList = ignoreList;
        }

        bool autoPatchEnabled = false;
        if (formSettings.Value.ReqOn || formSettings.Value.txtOn)
        {
            autoPatchEnabled = true;
        }




            bool stopBeforeLimit = false;
        

    
      
            if (formSettings.Value.ActorOn)
            {
                    foreach (var npc in state.LoadOrder.PriorityOrder.Npc().WinningOverrides())
                    {
               

                        ModKey modKey = npc.FormKey.ModKey.FileName;
                bool hasBeenPatched = false;
                
                if ( masterList.Count > formSettings.Value.maxNumP && stopBeforeLimit == false)
                {
                     stopBeforeLimit = true;
                    Console.WriteLine("Generated plugin will contain more than 250 masters.");
                  Console.WriteLine("The Reqtificator Lite will now stop patching and will save the esp.");
                  Console.WriteLine("To continue patching, copy this message somewhere you can read it and follow the steps below:");
                    Console.WriteLine("1. Close Synthesis");
                    Console.WriteLine("2. In your load order, enable the plugin that was just generated.");
                    Console.WriteLine("3. Start Synthesis");
                    Console.WriteLine("4. In synthesis, create a new group with a difffernt name and add a copy of the unofficialReqtificatorLite to the new group.");
                  Console.WriteLine("5. Run the Reqtificator Lite in this new synthesis group.");
                    Console.WriteLine("6. The Reqtificator Lite will start where it left off and continue to patch all records.");
                }
                if (stopBeforeLimit == true) {
                    continue;
                }
                 hasBeenPatched = npc.Keywords?.Any(s => s.FormKey == formKeyPatched) ?? false;
                if (hasBeenPatched == true)
                {
                  
                    continue;
                }

                uint npcFromSelectedMod = 0;
                if (autoPatchEnabled)
                    {
                    npcFromSelectedMod = 1;
                    if (modKey == "Requiem for the Indifferent.esp")
                    {
                        continue;
                    }
                   
                    bool npcInRFTI = false;
                    for (int i = 0; i < RFTImasterList?.Count; i++)
                        {
                       
                            if (modKey == RFTImasterList[i])
                            {

                            
                            npcInRFTI = true;
                            }
                        }
                    if (npcInRFTI == true)
                    {
                        continue;
                    }
                }
                    else
                    {
                        // ModKey modKeyOver = 
                        //if mod is not matched then skip
                        
                        foreach (var slectedPlugin in npcGroups.Select(x => x.ModKey.FileName))


                            if (modKey == slectedPlugin)
                            {
                                npcFromSelectedMod = 1;


                              

                              
                            }
                    }
                if (npcFromSelectedMod == 0)
                {
                    continue;
                }
                if (!masterList.Contains(modKey.ToString()))
                {
                    masterList.Add(modKey.ToString());
                }
                var modifiedNpc = state.PatchMod.Npcs.GetOrAddAsOverride(npc);
                    modifiedNpc.Keywords ??= new();
                if (formSettings.Value.spidOn == false)
                {
                    modifiedNpc.Keywords.Add(formkeyActor);
                }
                    
                    modifiedNpc.Keywords.Add(formKeyPatched);
                modifiedNpc.Perks ??= new();
                if (formSettings.Value.spidOn == true)
                {
                    for (int i = 0; i < DB_reqPerksAll?.Rows.Count; i++)
                    {
                        //  Console.WriteLine((string)DB_reqPerksAll.Rows[i][0]);

                        FormLink<IPerkGetter> perkToAdd = FormKey.Factory((string)DB_reqPerksAll.Rows[i][0]);
                        modifiedNpc.Perks.Add(new PerkPlacement()
                        {
                            Perk = perkToAdd,
                            Rank = 1
                        });

                    }
                    modifiedNpc.ActorEffect ??= new();
                    for (int i = 0; i < DB_reqSpellsAll?.Rows.Count; i++)
                    {


                        FormLink<ISpellGetter> SpellToAdd = FormKey.Factory((string)DB_reqSpellsAll.Rows[i][0]);
                        modifiedNpc.ActorEffect.Add(SpellToAdd);
                    }
                    FormLink<IRaceGetter> raceGetter = modifiedNpc.Race.FormKey;
                    var npcRace = raceGetter.Resolve(state.LinkCache);
                    var raceOrigin = npcRace.FormKey.ModKey.ToString();
                    
                    if (raceOrigin == "Skyrim.esm" || raceOrigin == "Dawnguard.esm" || raceOrigin == "Dragonborn.esm")
                    {

                        for (int i = 0; i < DB_reqSpellsRaces?.Rows.Count; i++)
                        {

                            if (npcRace.EditorID!.ToString() == (string)DB_reqSpellsRaces.Rows[i][1])
                            {
                                modifiedNpc.ActorEffect ??= new();
                                FormLink<ISpellGetter> SpellToAdd = FormKey.Factory((string)DB_reqSpellsRaces.Rows[i][0]);
                                modifiedNpc.ActorEffect.Add(SpellToAdd);

                            }

                        }
                        for (int i = 0; i < DB_reqPerksRaces?.Rows.Count; i++)
                        {



                            if (npcRace.EditorID!.ToString() == (string)DB_reqPerksRaces.Rows[i][1])
                            {
                                FormLink<IPerkGetter> perkToAdd = FormKey.Factory((string)DB_reqPerksRaces.Rows[i][0]);
                                modifiedNpc.Perks.Add(new PerkPlacement()
                                {
                                    Perk = perkToAdd,
                                    Rank = 1
                                });
                            }
                 

                        }

                        if (fozar == true)
                    {
                        for (int i = 0; i < DB_reqSpellsRaces_Fozar?.Rows.Count; i++)
                        {
                            if (npcRace.EditorID!.ToString() == (string)DB_reqSpellsRaces_Fozar.Rows[i][1])
                            {
                                modifiedNpc.ActorEffect ??= new();
                                FormLink<ISpellGetter> SpellToAdd = FormKey.Factory((string)DB_reqSpellsRaces_Fozar.Rows[i][0]);
                                modifiedNpc.ActorEffect.Add(SpellToAdd);

                            }

                        }
                            for (int i = 0; i < DB_reqPerksRaces_Fozar?.Rows.Count; i++)
                            {


                                
                                if (npcRace.EditorID!.ToString() == (string)DB_reqPerksRaces_Fozar.Rows[i][1])
                                {
                                    FormLink<IPerkGetter> perkToAdd = FormKey.Factory((string)DB_reqPerksRaces_Fozar.Rows[i][0]);
                                    modifiedNpc.Perks.Add(new PerkPlacement()
                                    {
                                        Perk = perkToAdd,
                                        Rank = 1
                                    });
                                }


                            }

                        }
                }
                    if (MagicRedone == true)
                    {
                        for (int i = 0; i < DB_reqPerksAll_MR?.Rows.Count; i++)
                        {
                            modifiedNpc.Perks ??= new();
                            FormLink<IPerkGetter> perkToAdd = FormKey.Factory((string)DB_reqPerksAll_MR.Rows[i][0]);
                            modifiedNpc.Perks.Add(new PerkPlacement()
                            {
                                Perk = perkToAdd,
                                Rank = 1
                            });

                        }
                    }
                    if (WeapRedone == true) {
                        modifiedNpc.Perks ??= new();
                        FormLink<IPerkGetter> perkToAdd = FormKey.Factory("000853:Requiem - Weapons and Armor Redone.esp");
                        FormLink<IPerkGetter> perkToAddsec = FormKey.Factory("0008E9:Requiem - Weapons and Armor Redone.esp");
                        modifiedNpc.Perks.Add(new PerkPlacement()
                        {
                            Perk = perkToAdd,
                            Rank = 1
                        });
                        modifiedNpc.Perks.Add(new PerkPlacement()
                        {
                            Perk = perkToAddsec,
                            Rank = 1
                        });
                    }


                }


            }



        }
            if (formSettings.Value.WeaponsOn)
            {
                foreach (var weap in state.LoadOrder.PriorityOrder.Weapon().WinningOverrides())
                {
                uint npcFromSelectedMod = 0;
                ModKey modKey = weap.FormKey.ModKey.FileName;
                bool hasBeenPatched = false;
               
                if ( masterList.Count > formSettings.Value.maxNumP && stopBeforeLimit == false)
                {
                    stopBeforeLimit = true;
                    Console.WriteLine("Generated plugin will contain more than 250 masters.");
                    Console.WriteLine("The Reqtificator Lite will now stop patching and will save the esp.");
                    Console.WriteLine("To continue patching, copy this message somewhere you can read it and follow the steps below:");
                    Console.WriteLine("1. Close Synthesis");
                    Console.WriteLine("2. In your load order, enable the plugin that was just generated.");
                    Console.WriteLine("3. Start Synthesis");
                    Console.WriteLine("4. In synthesis, create a new group with a difffernt name and add a copy of the unofficialReqtificatorLite to the new group.");
                    Console.WriteLine("5. Run the Reqtificator Lite in this new synthesis group.");
                    Console.WriteLine("6. The Reqtificator Lite will start where it left off and continue to patch all records.");
                }
                if (stopBeforeLimit == true)
                {
                    continue;
                }
                hasBeenPatched = weap.Keywords?.Any(s => s.FormKey == formKeyPatched) ?? false;
                if (hasBeenPatched == true)
                {
                    continue;
                }
                if (autoPatchEnabled)
                    {
                    npcFromSelectedMod = 1;
                    if (modKey == "Requiem for the Indifferent.esp")
                    {
                        continue;
                    }
                    bool npcInRFTI = false;
                    for (int i = 0; i < RFTImasterList?.Count; i++)
                    {
                        if (modKey == RFTImasterList[i])
                            
                        {
                            npcInRFTI = true;
                          
                        }
                    }
                    if (npcInRFTI == true)
                    {
                        continue;
                    }
                }
                    else
                    {
                        //if mod is not matched then skip
                       
                        foreach (var slectedPlugin in npcGroups.Select(x => x.ModKey.FileName))

                            if (modKey == slectedPlugin)
                                npcFromSelectedMod = 1;

                       
                    }
                if (npcFromSelectedMod == 0)
                {
                    continue;
                }
                float? factor = 1;
                bool? isBow = false;
                bool? isXBow = false;
                try
				{
                factor = weap.Data!.AnimationType switch
                        {
                            WeaponAnimationType.Bow => 4,
                            WeaponAnimationType.Crossbow => 4,
                            WeaponAnimationType.HandToHand => 6,
                            WeaponAnimationType.OneHandSword => 6,
                            WeaponAnimationType.OneHandDagger => 6,
                            WeaponAnimationType.OneHandAxe => 6,
                            WeaponAnimationType.OneHandMace => 6,
                            WeaponAnimationType.TwoHandSword => 6,
                            WeaponAnimationType.TwoHandAxe => 6,
                            _ => null
                        };


                       isBow = weap.Data!.AnimationType switch
                        {
                            WeaponAnimationType.Bow => true,
                            WeaponAnimationType.Crossbow => true,
                            WeaponAnimationType.HandToHand => false,
                            WeaponAnimationType.OneHandSword => false,
                            WeaponAnimationType.OneHandDagger => false,
                            WeaponAnimationType.OneHandAxe => false,
                            WeaponAnimationType.OneHandMace => false,
                            WeaponAnimationType.TwoHandSword => false,
                            WeaponAnimationType.TwoHandAxe => false,
                            _ => null
                        };
                    isXBow = weap.Data!.AnimationType switch
                        {
                            WeaponAnimationType.Bow => false,
                            WeaponAnimationType.Crossbow => true,
                            WeaponAnimationType.HandToHand => false,
                            WeaponAnimationType.OneHandSword => false,
                            WeaponAnimationType.OneHandDagger => false,
                            WeaponAnimationType.OneHandAxe => false,
                            WeaponAnimationType.OneHandMace => false,
                            WeaponAnimationType.TwoHandSword => false,
                            WeaponAnimationType.TwoHandAxe => false,
                            _ => null
                        };
				}
				catch{
					continue;
				}
                if (!masterList.Contains(modKey.ToString()))
                {
                    masterList.Add(modKey.ToString());
                }
                var modifiedWeap = state.PatchMod.Weapons.GetOrAddAsOverride(weap);
                        modifiedWeap.Keywords ??= new();

                if (formSettings.Value.spidOn == false)
                {
                    modifiedWeap.Keywords.Add(formkeyWeap);
                }
                        modifiedWeap.Keywords.Add(formKeyPatched);
                try
                        {
                    bool hasNoRescale = modifiedWeap.Keywords?.Any(s => s.FormKey == noDamgeRescale) ?? false;
                    if (hasNoRescale == false)
                    {
                        modifiedWeap.BasicStats!.Damage = (ushort)(modifiedWeap.BasicStats!.Damage * factor!);
                    }

                   
                        }
                        catch { }
                        try
                        {
                            if (isBow == false)
                            {
                        bool hasNoWeaponReach = modifiedWeap.Keywords?.Any(s => s.FormKey == noWeaponReach) ?? false;
                        if (hasNoWeaponReach == false)
                        {
                            modifiedWeap.Data!.Reach *= 0.7f;
                        }
                           
                            }


                        }
                        catch { }
                        try
                        {
                            modifiedWeap.Critical!.Damage = modifiedWeap.BasicStats!.Damage;
                        }
                        catch { }
                        try
                        {
                    bool hasNoBowSpeedRescale = modifiedWeap.Keywords?.Any(s => s.FormKey == NoBowSpeedRescale) ?? false;

                    if(hasNoBowSpeedRescale == false)
                    {
                        if (isBow == true)
                        {
                            if (isXBow == false)
                            {
                                modifiedWeap.Data!.Speed = 0.3704f;
                            }
                        }
                        if (isXBow == true)
                        {
                            modifiedWeap.Data!.Speed = 0.4445f;


                        }
                    }
                           
                        }
                        catch { }



                if (formSettings.Value.spidOn == true)
                {
                    for (int i = 0; i < DB_reqKeysWeapons?.Rows.Count; i++)
                    {
                        bool loopHasKeyword = modifiedWeap.Keywords?.Any(s => s.FormKey == FormKey.Factory((string)DB_reqKeysWeapons.Rows[i][1])) ?? false;
                        if (loopHasKeyword)
                        {
                            modifiedWeap.Keywords ??= new();
                            modifiedWeap.Keywords.Add(FormKey.Factory((string)DB_reqKeysWeapons.Rows[i][0]));

                        }
                    }
                }
                   



                // .BasicStats?.Damage = (ushort)(r.BasicStats.Damage * factor)
            }
            }
            if (formSettings.Value.ArrowsOn)
            {
           
            foreach (var ammoo in state.LoadOrder.PriorityOrder.Ammunition().WinningOverrides())
                {
                 uint npcFromSelectedMod = 0;
                
                    ModKey modKey = ammoo.FormKey.ModKey.FileName;
                
                bool hasBeenPatched = false;
                

                if ( masterList.Count > formSettings.Value.maxNumP && stopBeforeLimit == false)
                {
                    stopBeforeLimit = true;
                    Console.WriteLine("Generated plugin will contain more than 250 masters.");
                    Console.WriteLine("The Reqtificator Lite will now stop patching and will save the esp.");
                    Console.WriteLine("To continue patching, copy this message somewhere you can read it and follow the steps below:");
                    Console.WriteLine("1. Close Synthesis");
                    Console.WriteLine("2. In your load order, enable the plugin that was just generated.");
                    Console.WriteLine("3. Start Synthesis");
                    Console.WriteLine("4. In synthesis, create a new group with a difffernt name and add a copy of the unofficialReqtificatorLite to the new group.");
                    Console.WriteLine("5. Run the Reqtificator Lite in this new synthesis group.");
                    Console.WriteLine("6. The Reqtificator Lite will start where it left off and continue to patch all records.");
                }
                if (stopBeforeLimit == true)
                {
                    continue;
                }
                hasBeenPatched = ammoo.Keywords?.Any(s => s.FormKey == formKeyPatched) ?? false;
                if (hasBeenPatched == true)
                {
                    continue;
                }

               
               bool hasNoRescale = ammoo.Keywords?.Any(s => s.FormKey == noDamgeRescale) ?? false;
                if (hasNoRescale == true)
                {
                    continue;
                }


                if (autoPatchEnabled)
                    {npcFromSelectedMod = 1;

                    if (modKey == "Requiem for the Indifferent.esp")
                    {
                        continue;
                    }
                    bool npcInRFTI = false;
                    for (int i = 0; i < RFTImasterList?.Count; i++)
                    {
                        if (modKey == RFTImasterList[i])

                        {
                            npcInRFTI = true;
                        }
                    }
                    if (npcInRFTI == true)
                    {
                        continue;
                    }
                }
                    else
                    {
                        //if mod is not matched then skip
                       
                        foreach (var slectedPlugin in npcGroups.Select(x => x.ModKey.FileName))

                            if (modKey == slectedPlugin)
                                npcFromSelectedMod = 1;

                       
                    }
                if (npcFromSelectedMod == 0)
                {
                    continue;
                }
                try
                        {
                            if (ammoo.Damage > 0)
                            {
                        if (!masterList.Contains(modKey.ToString()))
                        {
                            masterList.Add(modKey.ToString());
                        }
                        var moddifiedAmmo = state.PatchMod.Ammunitions.GetOrAddAsOverride(ammoo);
                        moddifiedAmmo.Damage *= 4;
                        
                            moddifiedAmmo.Keywords ??= new();
                            moddifiedAmmo.Keywords.Add(formKeyPatched);
                          
                        

                            }

                        }
                        catch { }

                    



                }
            }
            if (formSettings.Value.ArmorOn)
            {
                foreach (var armo in state.LoadOrder.PriorityOrder.Armor().WinningOverrides())
            {
                uint npcFromSelectedMod = 0;
                ModKey modKey = armo.FormKey.ModKey.FileName;
                bool hasBeenPatched = false;
               
                if ( masterList.Count > formSettings.Value.maxNumP && stopBeforeLimit == false)
                {
                    stopBeforeLimit = true;
                    Console.WriteLine("Generated plugin will contain more than 250 masters.");
                    Console.WriteLine("The Reqtificator Lite will now stop patching and will save the esp.");
                    Console.WriteLine("To continue patching, copy this message somewhere you can read it and follow the steps below:");
                    Console.WriteLine("1. Close Synthesis");
                    Console.WriteLine("2. In your load order, enable the plugin that was just generated.");
                    Console.WriteLine("3. Start Synthesis");
                    Console.WriteLine("4. In synthesis, create a new group with a difffernt name and add a copy of the unofficialReqtificatorLite to the new group.");
                    Console.WriteLine("5. Run the Reqtificator Lite in this new synthesis group.");
                    Console.WriteLine("6. The Reqtificator Lite will start where it left off and continue to patch all records.");
                }
                if (stopBeforeLimit == true)
                {
                    continue;
                }
                hasBeenPatched = armo.Keywords?.Any(s => s.FormKey == formKeyPatched) ?? false;
                if (hasBeenPatched == true)
                {
                    continue;
                }


                if (autoPatchEnabled)
                    {npcFromSelectedMod = 1;
                    if (modKey == "Requiem for the Indifferent.esp")
                    {
                        continue;
                    }
                    bool npcInRFTI = false;
                    for (int i = 0; i < RFTImasterList?.Count; i++)
                    {
                        if (modKey == RFTImasterList[i])

                        {
                            npcInRFTI = true;
                        }
                    }
                    if (npcInRFTI == true)
                    {
                        continue;
                    }
                }
                    else
                    {
                        //if mod is not matched then skip
                       
                        foreach (var slectedPlugin in npcGroups.Select(x => x.ModKey.FileName))

                            if (modKey == slectedPlugin)
                                npcFromSelectedMod = 1;

                     
                    }
                if (npcFromSelectedMod == 0)
                {
                    continue;
                }
                float offset = 18.0f;
                        float factor = 3.3f;
                bool hasnoArmorRescale = false;
                        try
                        {
                            var armorType = armo.BodyTemplate?.ArmorType;
                            var slot = armo.BodyTemplate?.FirstPersonFlags;
                            //Console.WriteLine($"{armorType} {slot}");

                            if (slot.ToString()!.Contains("Body"))
                            {
                                offset = 66.0f;
                            }
                    if (armorType.ToString() == "HeavyArmor")
                    {
                        factor = 6.6f;
                    }
                       

                            if (armorType.ToString() == "HeavyArmor" || armorType.ToString() == "LightArmor")
                            {
                                if (slot.ToString()!.Contains("Ears") || slot.ToString()!.Contains("Hair") || slot.ToString()!.Contains("Circlet") || slot.ToString()!.Contains("Body") || slot.ToString()!.Contains("Head") || slot.ToString()!.Contains("Feet") || slot.ToString()!.Contains("Hands") || slot.ToString()!.Contains("Shield") )
                                {
                            if (!masterList.Contains(modKey.ToString()))
                            {
                                masterList.Add(modKey.ToString());
                            }
                            var modifiedArmo = state.PatchMod.Armors.GetOrAddAsOverride(armo);

                                    modifiedArmo.Keywords ??= new();
                            if (formSettings.Value.spidOn == false)
                            {
                                modifiedArmo.Keywords.Add(formkeyArmo);
                            }
                                    modifiedArmo.Keywords.Add(formKeyPatched);
                          if(modifiedArmo.ArmorRating > 0)
                            {

                                 hasnoArmorRescale = modifiedArmo.Keywords?.Any(s => s.FormKey == noArmorRescale) ?? false;
                                if (armorType.ToString() == "HeavyArmor")
                                {

                                    if (slot.ToString()!.Contains("Body"))
                                    {
                                        if (armo.ArmorRating >= 74) { hasnoArmorRescale = true; }
                                    }
                                    if (slot.ToString()!.Contains("Head"))
                                    {
                                        if (armo.ArmorRating >= 35) { hasnoArmorRescale = true; }
                                    }
                                    if (slot.ToString()!.Contains("Circlet"))
                                    {
                                        if (armo.ArmorRating >= 35) { hasnoArmorRescale = true; }
                                    }
                                    if (slot.ToString()!.Contains("Hair"))
                                    {
                                        if (armo.ArmorRating >= 35) { hasnoArmorRescale = true; }
                                    }
                                    if (slot.ToString()!.Contains("Long Hair"))
                                    {
                                        if (armo.ArmorRating >= 35) { hasnoArmorRescale = true; }
                                    }
                                    if (slot.ToString()!.Contains("Ears"))
                                    {
                                        if (armo.ArmorRating >= 35) { hasnoArmorRescale = true; }
                                    }
                                    if (slot.ToString()!.Contains("Feet"))
                                    {
                                        if (armo.ArmorRating >= 27) { hasnoArmorRescale = true; }
                                    }
                                    if (slot.ToString()!.Contains("Hands"))
                                    {
                                        if (armo.ArmorRating >= 27) { hasnoArmorRescale = true; }
                                    }
                                    if (slot.ToString()!.Contains("Shield"))
                                    {
                                        if (armo.ArmorRating >= 54) { hasnoArmorRescale = true; }
                                    }
                                }
                                if (armorType.ToString() == "LightArmor")
                                {
                                    if (slot.ToString()!.Contains("Body"))
                                    {
                                        if (armo.ArmorRating >= 62) { hasnoArmorRescale = true; }
                                    }
                                    if (slot.ToString()!.Contains("Head"))
                                    {
                                        if (armo.ArmorRating >= 26) { hasnoArmorRescale = true; }
                                    }
                                    if (slot.ToString()!.Contains("Circlet"))
                                    {
                                        if (armo.ArmorRating >= 26) { hasnoArmorRescale = true; }
                                    }
                                    if (slot.ToString()!.Contains("Hair"))
                                    {
                                        if (armo.ArmorRating >= 26) { hasnoArmorRescale = true; }
                                    }
                                    if (slot.ToString()!.Contains("Long Hair"))
                                    {
                                        if (armo.ArmorRating >= 26) { hasnoArmorRescale = true; }
                                    }
                                    if (slot.ToString()!.Contains("Ears"))
                                    {
                                        if (armo.ArmorRating >= 26) { hasnoArmorRescale = true; }
                                    }
                                    if (slot.ToString()!.Contains("Feet"))
                                    {
                                        if (armo.ArmorRating >= 18) { hasnoArmorRescale = true; }
                                    }
                                    if (slot.ToString()!.Contains("Hands"))
                                    {
                                        if (armo.ArmorRating >= 18) { hasnoArmorRescale = true; }
                                    }
                                    if (slot.ToString()!.Contains("Shield"))
                                    {
                                        if (armo.ArmorRating >= 44) { hasnoArmorRescale = true; }
                                    }
                                }
                                if (hasnoArmorRescale == false)
                                {
                                    modifiedArmo.ArmorRating = modifiedArmo.ArmorRating * factor + offset;
                                }
                                
                            }
                                  
                            if (formSettings.Value.spidOn == true)
                            {
                                for (int i = 0; i < DB_reqKeysArmor?.Rows.Count; i++)
                                {
                                    bool loopHasKeyword = modifiedArmo.Keywords?.Any(s => s.FormKey == FormKey.Factory((string)DB_reqKeysArmor.Rows[i][1])) ?? false;
                                    if (loopHasKeyword)
                                    {
                                        modifiedArmo.Keywords ??= new();
                                        modifiedArmo.Keywords.Add(FormKey.Factory((string)DB_reqKeysArmor.Rows[i][0]));

                                    }
                                }
                                bool isBodyArm = modifiedArmo.Keywords?.Any(s => s.FormKey == FormKey.Factory((string)DB_reqKeysArmorBody!.Rows[0][2])) ?? false;
                                if (isBodyArm)
                                {
                                    for (int i = 0; i < DB_reqKeysArmorBody?.Rows.Count; i++)
                                    {
                                        bool loopHasKeyword = modifiedArmo.Keywords?.Any(s => s.FormKey == FormKey.Factory((string)DB_reqKeysArmorBody.Rows[i][1])) ?? false;
                                        if (loopHasKeyword)
                                        {
                                            modifiedArmo.Keywords ??= new();
                                            modifiedArmo.Keywords.Add(FormKey.Factory((string)DB_reqKeysArmorBody.Rows[i][0]));

                                        }
                                    }
                                }
                            }
                                     


                        }

                    }
                        }
                        catch { }
                    

                    


                }
            }
            if (formSettings.Value.DoorsOn)
            {

                foreach (var doorr in state.LoadOrder.PriorityOrder.Door().WinningOverrides())
                {
                uint npcFromSelectedMod = 0;
                ModKey modKey = doorr.FormKey.ModKey.FileName;
                if (masterList.Count > formSettings.Value.maxNumP && stopBeforeLimit == false)
                {
                    stopBeforeLimit = true;
                    Console.WriteLine("Generated plugin will contain more than 250 masters.");
                    Console.WriteLine("The Reqtificator Lite will now stop patching and will save the esp.");
                    Console.WriteLine("To continue patching, copy this message somewhere you can read it and follow the steps below:");
                    Console.WriteLine("1. Close Synthesis");
                    Console.WriteLine("2. In your load order, enable the plugin that was just generated.");
                    Console.WriteLine("3. Start Synthesis");
                    Console.WriteLine("4. In synthesis, create a new group with a difffernt name and add a copy of the unofficialReqtificatorLite to the new group.");
                    Console.WriteLine("5. Run the Reqtificator Lite in this new synthesis group.");
                    Console.WriteLine("6. The Reqtificator Lite will start where it left off and continue to patch all records.");
                }
                if (stopBeforeLimit == true)
                {
                    continue;
                }
                if (autoPatchEnabled)
                    {npcFromSelectedMod = 1;
                    if (modKey == "Requiem for the Indifferent.esp")
                    {
                        continue;
                    }
                    bool npcInRFTI = false;
                    for (int i = 0; i < RFTImasterList?.Count; i++)
                    {
                        if (modKey == RFTImasterList[i])

                        {
                            npcInRFTI = true;
                        }
                    }
                    if (npcInRFTI == true)
                    {
                        continue;
                    }
                }
                    else
                    {
                        //if mod is not matched then skip
                       
                        foreach (var slectedPlugin in npcGroups.Select(x => x.ModKey.FileName))

                            if (modKey == slectedPlugin)
                                npcFromSelectedMod = 1;

                     
                    }
                if (npcFromSelectedMod == 0)
                {
                    continue;
                }
                bool lockpickingScriptBound = doorr.VirtualMachineAdapter?.Scripts.Any(s => s.Name == lockPickingControScript.Name) ?? false; 
                if (lockpickingScriptBound) {
                    continue; }

                if (!masterList.Contains(modKey.ToString()))
                {
                    masterList.Add(modKey.ToString());
                }
                var modifiedDoorr = state.PatchMod.Doors.GetOrAddAsOverride(doorr);
                        modifiedDoorr.VirtualMachineAdapter ??= new VirtualMachineAdapter();
                        modifiedDoorr.VirtualMachineAdapter.Scripts.Add(lockPickingControScript);
                




                }

            }
            if (formSettings.Value.ContOn)
            {
                foreach (var contt in state.LoadOrder.PriorityOrder.Container().WinningOverrides())
                {
                uint npcFromSelectedMod = 0;
                ModKey modKey = contt.FormKey.ModKey.FileName;
                if (masterList.Count > formSettings.Value.maxNumP && stopBeforeLimit == false)
                {
                    stopBeforeLimit = true;
                    Console.WriteLine("Generated plugin will contain more than 250 masters.");
                    Console.WriteLine("The Reqtificator Lite will now stop patching and will save the esp.");
                    Console.WriteLine("To continue patching, copy this message somewhere you can read it and follow the steps below:");
                    Console.WriteLine("1. Close Synthesis");
                    Console.WriteLine("2. In your load order, enable the plugin that was just generated.");
                    Console.WriteLine("3. Start Synthesis");
                    Console.WriteLine("4. In synthesis, create a new group with a difffernt name and add a copy of the unofficialReqtificatorLite to the new group.");
                    Console.WriteLine("5. Run the Reqtificator Lite in this new synthesis group.");
                    Console.WriteLine("6. The Reqtificator Lite will start where it left off and continue to patch all records.");
                }
                if (stopBeforeLimit == true)
                {
                    continue;
                }
                if (autoPatchEnabled)
                    {npcFromSelectedMod = 1;
                    if (modKey == "Requiem for the Indifferent.esp")
                    {
                        continue;
                    }
                    bool npcInRFTI = false;
                    for (int i = 0; i < RFTImasterList?.Count; i++)
                    {
                        if (modKey == RFTImasterList[i])

                        {
                            npcInRFTI = true;
                        }
                    }
                    if (npcInRFTI == true)
                    {
                        continue;
                    }
                }
                    else
                    {
                        //if mod is not matched then skip
                        
                        foreach (var slectedPlugin in npcGroups.Select(x => x.ModKey.FileName))

                            if (modKey == slectedPlugin)
                                npcFromSelectedMod = 1;

                       
                    }
                if (npcFromSelectedMod == 0)
                {
                    continue;
                }

                bool lockpickingScriptBound = contt.VirtualMachineAdapter?.Scripts.Any(s => s.Name == lockPickingControScript.Name) ?? false;
                if (lockpickingScriptBound)
                {
                    continue;
                }
                if (!masterList.Contains(modKey.ToString()))
                {
                    masterList.Add(modKey.ToString());
                }
                var modifiedContt = state.PatchMod.Containers.GetOrAddAsOverride(contt);
                        modifiedContt.VirtualMachineAdapter ??= new VirtualMachineAdapter();
                        modifiedContt.VirtualMachineAdapter.Scripts.Add(lockPickingControScript);
                    
                   
                }

            }
        
      









    }
}
