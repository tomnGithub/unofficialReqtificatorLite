using System;
using System.Collections.Generic;
using System.Data;
using System.Globalization;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.IO;
using DynamicData.Kernel;
using Mutagen.Bethesda;
using Mutagen.Bethesda.FormKeys.SkyrimSE;
using Mutagen.Bethesda.Plugins;
using Mutagen.Bethesda.Skyrim;
using Mutagen.Bethesda.Synthesis;
using Noggog;
using System.Text.RegularExpressions;
using System.Reflection;
using System.Reflection.Metadata;
using CommandLine;
using System.Linq;
using Mutagen.Bethesda;
using Mutagen.Bethesda.Plugins.Records;
using Mutagen.Bethesda.Skyrim;
using ScriptProperty = Mutagen.Bethesda.Skyrim.ScriptProperty;
using VirtualMachineAdapter = Mutagen.Bethesda.Skyrim.VirtualMachineAdapter;
using IQuest = Mutagen.Bethesda.Skyrim.IQuest;
using System.Collections;


// Function to initialize the matches dictionary with all keys set to 0


namespace unofficialReqtificatorLite;

public class Program
{
    private static Lazy<Settings> formSettings = null!;

    static void WriteToIniFile(string filePath, string text)
    {
        // Open the file for appending
        using (StreamWriter writer = new StreamWriter(filePath, true, Encoding.UTF8))
        {
            // Write the text to the file
            writer.WriteLine(text);
        }
    }
    static void ClearFile(string filePath)
    {
        // Open the file for writing and clear its content
        using (StreamWriter writer = new StreamWriter(filePath, false, Encoding.UTF8))
        {
            // Write nothing to the file (effectively clearing its content)
        }
    }

    public static Task<int> Main(string[] args)
    {
        return SynthesisPipeline.Instance
            .AddPatch<ISkyrimMod, ISkyrimModGetter>(RunPatch)
            .SetAutogeneratedSettings(
                "Settings",
                "Settings.json",
                out formSettings)
            .SetTypicalOpen(GameRelease.SkyrimSE, "unofficialReqtificatorLite.esp")
            .Run(args);
    }
    
    public static void RunPatch(IPatcherState<ISkyrimMod, ISkyrimModGetter> state)
    {
        var npcGroups = state.LoadOrder.PriorityOrder.Reverse()
            .Select(listing => listing.Mod)
            .NotNull()
            .Select(x => (x.ModKey, x.Npcs))
            .Where(x => formSettings.Value.TargetMods.Contains(x.ModKey))
            .ToArray();
        if (formSettings.Value.ReqOn)
        {
            Console.WriteLine("Now patching mods not patched by Requiem for the Indifferent.esp");
        }
        else
        {
            Console.WriteLine("Patching the Selected Plugins:");
            foreach (var modKey in npcGroups.Select(x => x.ModKey))
            {
                Console.WriteLine($"  {modKey}");

            }
        }
          

        
        FormKey formkeyActor = FormKey.Factory("000800:RFTI_Alternative_Keyword.esp");
        FormKey formkeyWeap = FormKey.Factory("000801:RFTI_Alternative_Keyword.esp");
        FormKey formkeyArmo = FormKey.Factory("000802:RFTI_Alternative_Keyword.esp");
        FormKey formKeyPatched = FormKey.Factory("000802:RFTI_Alternative_Keyword.esp");


        bool formKeyUptoDate = false;
        try
        {
             formKeyPatched = FormKey.Factory("000803:RFTI_Alternative_Keyword.esp");
            formKeyUptoDate = true;

        }
        catch (Exception ex)
        {
            Console.WriteLine("RFTI_Alternative_Keyword.esp IS NOT UP TO DATE.");
            Console.WriteLine("Please download update from nexus page.");
        }

        var newKeyGetter = Skyrim.Keyword.ActorTypeNPC.Resolve(state.LinkCache);

        if (formKeyUptoDate == false)
        {
            var newKey = state.PatchMod.Keywords.DuplicateInAsNewRecord(newKeyGetter);
            newKey.EditorID = "patched_RFTIAlternative";
            formKeyPatched = newKey.FormKey;
        }
       

        foreach (var keyy in state.LoadOrder.PriorityOrder.Keyword().WinningOverrides()){

        }
        

        //public readonly Mutagen.Bethesda.Skyrim.ScriptEntry _lockPickingScript;
        var lockPickingControScript = new Mutagen.Bethesda.Skyrim.ScriptEntry
        {
            Name = "REQ_LockpickControl"
        };

        var FormKeyReqQuest = new FormLink<IQuestGetter>(FormKey.Factory("AD3B22:Requiem.esp"));
        lockPickingControScript.Properties.Add(new Mutagen.Bethesda.Skyrim.ScriptObjectProperty()
        {
            Name = "dataStorage",
            Alias = 18,
            Object = FormKeyReqQuest,
            Flags = ScriptProperty.Flag.Edited
        });
        //1182F3AF
        var FormKeyReqQuest2 = new FormLink<IQuestGetter>(FormKey.Factory("82F3AF:Requiem.esp"));
        lockPickingControScript.Properties.Add(new Mutagen.Bethesda.Skyrim.ScriptObjectProperty()
        {
            Name = "FollowerControl",
            Object = FormKeyReqQuest2,
            Flags = ScriptProperty.Flag.Edited
        });

        var mod = state.LoadOrder.TryGetValue("Requiem for the Indifferent.esp");
        //Console.WriteLine(mod);
        var masters = mod?.Mod?.ModHeader.MasterReferences;
        List<string> masterList = new List<string>();
        bool stopBeforeLimit = false;
        

    
      
            if (formSettings.Value.ActorOn)
            {
                    foreach (var npc in state.LoadOrder.PriorityOrder.Npc().WinningOverrides())
                    {


                        ModKey modKey = npc.FormKey.ModKey.FileName;
                bool hasBeenPatched = false;
                
                if ( masterList.Count > 250 && stopBeforeLimit == false)
                {
                     stopBeforeLimit = true;
                    Console.WriteLine("Generated plugin will contain more than 250 masters.");
                  Console.WriteLine("The Reqtificator Lite will now stop patching and will save the esp.");
                  Console.WriteLine("To continue patching, copy this message somewhere you can read it and follow the steps below:");
                    Console.WriteLine("1. Close Synthesis");
                    Console.WriteLine("2. In your load order, enable the plugin that was just generated.");
                    Console.WriteLine("3. Start Synthesis");
                    Console.WriteLine("4. In synthesis, create a new group with a difffernt name and add a copy of the unofficialReqtificatorLite to the new group.");
                  Console.WriteLine("5. Run the Reqtificator Lite in this new synthesis group.");
                    Console.WriteLine("6. The Reqtificator Lite will start where it left off and continue to patch all records.");
                }
                if (stopBeforeLimit == true) {
                    continue;
                }
                 hasBeenPatched = npc.Keywords?.Any(s => s.FormKey == formKeyPatched) ?? false;
                if (hasBeenPatched == true)
                {
                  
                    continue;
                }

                uint npcFromSelectedMod = 0;
                if (formSettings.Value.ReqOn)
                    {
                    npcFromSelectedMod = 1;
                    if (modKey == "Requiem for the Indifferent.esp")
                    {
                        continue;
                    }
                   
                    bool npcInRFTI = false;
                    for (int i = 0; i < masters?.Count; i++)
                        {
                            if (modKey == masters?[i].Master.FileName)
                            {
                            
                            npcInRFTI = true;
                            }
                        }
                    if (npcInRFTI == true)
                    {
                        continue;
                    }
                }
                    else
                    {
                        // ModKey modKeyOver = 
                        //if mod is not matched then skip
                        
                        foreach (var slectedPlugin in npcGroups.Select(x => x.ModKey.FileName))


                            if (modKey == slectedPlugin)
                            {
                                npcFromSelectedMod = 1;


                              

                              
                            }
                    }
                if (npcFromSelectedMod == 0)
                {
                    continue;
                }
                if (!masterList.Contains(modKey.ToString()))
                {
                    masterList.Add(modKey.ToString());
                }
                var modifiedNpc = state.PatchMod.Npcs.GetOrAddAsOverride(npc);
                    modifiedNpc.Keywords ??= new();
                    modifiedNpc.Keywords.Add(formkeyActor);
                    modifiedNpc.Keywords.Add(formKeyPatched);
            }
               
                

            }
            if (formSettings.Value.WeaponsOn)
            {
                foreach (var weap in state.LoadOrder.PriorityOrder.Weapon().WinningOverrides())
                {
                uint npcFromSelectedMod = 0;
                ModKey modKey = weap.FormKey.ModKey.FileName;
                bool hasBeenPatched = false;
               
                if ( masterList.Count > 250 && stopBeforeLimit == false)
                {
                    stopBeforeLimit = true;
                    Console.WriteLine("Generated plugin will contain more than 250 masters.");
                    Console.WriteLine("The Reqtificator Lite will now stop patching and will save the esp.");
                    Console.WriteLine("To continue patching, copy this message somewhere you can read it and follow the steps below:");
                    Console.WriteLine("1. Close Synthesis");
                    Console.WriteLine("2. In your load order, enable the plugin that was just generated.");
                    Console.WriteLine("3. Start Synthesis");
                    Console.WriteLine("4. In synthesis, create a new group with a difffernt name and add a copy of the unofficialReqtificatorLite to the new group.");
                    Console.WriteLine("5. Run the Reqtificator Lite in this new synthesis group.");
                    Console.WriteLine("6. The Reqtificator Lite will start where it left off and continue to patch all records.");
                }
                if (stopBeforeLimit == true)
                {
                    continue;
                }
                hasBeenPatched = weap.Keywords?.Any(s => s.FormKey == formKeyPatched) ?? false;
                if (hasBeenPatched == true)
                {
                    continue;
                }
                if (formSettings.Value.ReqOn)
                    {
                    npcFromSelectedMod = 1;
                    if (modKey == "Requiem for the Indifferent.esp")
                    {
                        continue;
                    }
                    bool npcInRFTI = false;
                    for (int i = 0; i < masters?.Count; i++)
                    {
                        if (modKey == masters?[i].Master.FileName)
                            
                        {
                            npcInRFTI = true;
                          
                        }
                    }
                    if (npcInRFTI == true)
                    {
                        continue;
                    }
                }
                    else
                    {
                        //if mod is not matched then skip
                       
                        foreach (var slectedPlugin in npcGroups.Select(x => x.ModKey.FileName))

                            if (modKey == slectedPlugin)
                                npcFromSelectedMod = 1;

                       
                    }
                if (npcFromSelectedMod == 0)
                {
                    continue;
                }
                float? factor = weap.Data!.AnimationType switch
                        {
                            WeaponAnimationType.Bow => 4,
                            WeaponAnimationType.Crossbow => 4,
                            WeaponAnimationType.HandToHand => 6,
                            WeaponAnimationType.OneHandSword => 6,
                            WeaponAnimationType.OneHandDagger => 6,
                            WeaponAnimationType.OneHandAxe => 6,
                            WeaponAnimationType.OneHandMace => 6,
                            WeaponAnimationType.TwoHandSword => 6,
                            WeaponAnimationType.TwoHandAxe => 6,
                            _ => null
                        };


                        bool? isBow = weap.Data!.AnimationType switch
                        {
                            WeaponAnimationType.Bow => true,
                            WeaponAnimationType.Crossbow => true,
                            WeaponAnimationType.HandToHand => false,
                            WeaponAnimationType.OneHandSword => false,
                            WeaponAnimationType.OneHandDagger => false,
                            WeaponAnimationType.OneHandAxe => false,
                            WeaponAnimationType.OneHandMace => false,
                            WeaponAnimationType.TwoHandSword => false,
                            WeaponAnimationType.TwoHandAxe => false,
                            _ => null
                        };
                        bool? isXBow = weap.Data!.AnimationType switch
                        {
                            WeaponAnimationType.Bow => false,
                            WeaponAnimationType.Crossbow => true,
                            WeaponAnimationType.HandToHand => false,
                            WeaponAnimationType.OneHandSword => false,
                            WeaponAnimationType.OneHandDagger => false,
                            WeaponAnimationType.OneHandAxe => false,
                            WeaponAnimationType.OneHandMace => false,
                            WeaponAnimationType.TwoHandSword => false,
                            WeaponAnimationType.TwoHandAxe => false,
                            _ => null
                        };

                if (!masterList.Contains(modKey.ToString()))
                {
                    masterList.Add(modKey.ToString());
                }
                var modifiedWeap = state.PatchMod.Weapons.GetOrAddAsOverride(weap);
                        modifiedWeap.Keywords ??= new();
                        modifiedWeap.Keywords.Add(formkeyWeap);
                        modifiedWeap.Keywords.Add(formKeyPatched);
                try
                        {
                            modifiedWeap.BasicStats!.Damage = (ushort)(modifiedWeap.BasicStats!.Damage * factor!);
                        }
                        catch { }
                        try
                        {
                            if (isBow == false)
                            {
                                modifiedWeap.Data!.Reach *= 0.7f;
                            }


                        }
                        catch { }
                        try
                        {
                            modifiedWeap.Critical!.Damage = modifiedWeap.BasicStats!.Damage;
                        }
                        catch { }
                        try
                        {
                            if (isBow == true)
                            {
                                if (isXBow == false)
                                {
                                    modifiedWeap.Data!.Speed = 0.3704f;
                                }
                            }
                            if (isXBow == true)
                            {
                                modifiedWeap.Data!.Speed = 0.4445f;


                            }
                        }
                        catch { }
                    
                   





                    // .BasicStats?.Damage = (ushort)(r.BasicStats.Damage * factor)
                }
            }
            if (formSettings.Value.ArrowsOn)
            {
           
            foreach (var ammoo in state.LoadOrder.PriorityOrder.Ammunition().WinningOverrides())
                {
                 uint npcFromSelectedMod = 0;

                    ModKey modKey = ammoo.FormKey.ModKey.FileName;
                bool hasBeenPatched = false;
                
                if ( masterList.Count > 250 && stopBeforeLimit == false)
                {
                    stopBeforeLimit = true;
                    Console.WriteLine("Generated plugin will contain more than 250 masters.");
                    Console.WriteLine("The Reqtificator Lite will now stop patching and will save the esp.");
                    Console.WriteLine("To continue patching, copy this message somewhere you can read it and follow the steps below:");
                    Console.WriteLine("1. Close Synthesis");
                    Console.WriteLine("2. In your load order, enable the plugin that was just generated.");
                    Console.WriteLine("3. Start Synthesis");
                    Console.WriteLine("4. In synthesis, create a new group with a difffernt name and add a copy of the unofficialReqtificatorLite to the new group.");
                    Console.WriteLine("5. Run the Reqtificator Lite in this new synthesis group.");
                    Console.WriteLine("6. The Reqtificator Lite will start where it left off and continue to patch all records.");
                }
                if (stopBeforeLimit == true)
                {
                    continue;
                }
                hasBeenPatched = ammoo.Keywords?.Any(s => s.FormKey == formKeyPatched) ?? false;
                if (hasBeenPatched == true)
                {
                    continue;
                }
                if (formSettings.Value.ReqOn)
                    {npcFromSelectedMod = 1;

                    if (modKey == "Requiem for the Indifferent.esp")
                    {
                        continue;
                    }
                    bool npcInRFTI = false;
                    for (int i = 0; i < masters?.Count; i++)
                    {
                        if (modKey == masters?[i].Master.FileName)

                        {
                            npcInRFTI = true;
                        }
                    }
                    if (npcInRFTI == true)
                    {
                        continue;
                    }
                }
                    else
                    {
                        //if mod is not matched then skip
                       
                        foreach (var slectedPlugin in npcGroups.Select(x => x.ModKey.FileName))

                            if (modKey == slectedPlugin)
                                npcFromSelectedMod = 1;

                       
                    }
                if (npcFromSelectedMod == 0)
                {
                    continue;
                }
                try
                        {
                            if (ammoo.Damage > 0)
                            {
                        if (!masterList.Contains(modKey.ToString()))
                        {
                            masterList.Add(modKey.ToString());
                        }
                        var moddifiedAmmo = state.PatchMod.Ammunitions.GetOrAddAsOverride(ammoo);
                                moddifiedAmmo.Damage *= 4;
                        moddifiedAmmo.Keywords ??= new();
                        moddifiedAmmo.Keywords.Add(formKeyPatched);

                            }

                        }
                        catch { }

                    



                }
            }
            if (formSettings.Value.ArmorOn)
            {
                foreach (var armo in state.LoadOrder.PriorityOrder.Armor().WinningOverrides())
            {
                uint npcFromSelectedMod = 0;
                ModKey modKey = armo.FormKey.ModKey.FileName;
                bool hasBeenPatched = false;
               
                if ( masterList.Count > 250 && stopBeforeLimit == false)
                {
                    stopBeforeLimit = true;
                    Console.WriteLine("Generated plugin will contain more than 250 masters.");
                    Console.WriteLine("The Reqtificator Lite will now stop patching and will save the esp.");
                    Console.WriteLine("To continue patching, copy this message somewhere you can read it and follow the steps below:");
                    Console.WriteLine("1. Close Synthesis");
                    Console.WriteLine("2. In your load order, enable the plugin that was just generated.");
                    Console.WriteLine("3. Start Synthesis");
                    Console.WriteLine("4. In synthesis, create a new group with a difffernt name and add a copy of the unofficialReqtificatorLite to the new group.");
                    Console.WriteLine("5. Run the Reqtificator Lite in this new synthesis group.");
                    Console.WriteLine("6. The Reqtificator Lite will start where it left off and continue to patch all records.");
                }
                if (stopBeforeLimit == true)
                {
                    continue;
                }
                hasBeenPatched = armo.Keywords?.Any(s => s.FormKey == formKeyPatched) ?? false;
                if (hasBeenPatched == true)
                {
                    continue;
                }


                if (formSettings.Value.ReqOn)
                    {npcFromSelectedMod = 1;
                    if (modKey == "Requiem for the Indifferent.esp")
                    {
                        continue;
                    }
                    bool npcInRFTI = false;
                    for (int i = 0; i < masters?.Count; i++)
                    {
                        if (modKey == masters?[i].Master.FileName)

                        {
                            npcInRFTI = true;
                        }
                    }
                    if (npcInRFTI == true)
                    {
                        continue;
                    }
                }
                    else
                    {
                        //if mod is not matched then skip
                       
                        foreach (var slectedPlugin in npcGroups.Select(x => x.ModKey.FileName))

                            if (modKey == slectedPlugin)
                                npcFromSelectedMod = 1;

                     
                    }
                if (npcFromSelectedMod == 0)
                {
                    continue;
                }
                float offset = 18.0f;
                        float factor = 3.3f;
                        try
                        {
                            var armorType = armo.BodyTemplate?.ArmorType;
                            var slot = armo.BodyTemplate?.FirstPersonFlags;
                            //Console.WriteLine($"{armorType} {slot}");

                            if (slot.ToString()!.Contains("Body"))
                            {
                                offset = 66.0f;
                            }
                            if (armorType.ToString() == "HeavyArmor")
                            {
                                factor = 6.6f;
                            }

                            if (armorType.ToString() == "HeavyArmor" || armorType.ToString() == "LightArmor")
                            {
                                if (slot.ToString()!.Contains("Body") || slot.ToString()!.Contains("Head") || slot.ToString()!.Contains("Feet") || slot.ToString()!.Contains("Hands"))
                                {
                            if (!masterList.Contains(modKey.ToString()))
                            {
                                masterList.Add(modKey.ToString());
                            }
                            var modifiedArmo = state.PatchMod.Armors.GetOrAddAsOverride(armo);

                                    modifiedArmo.Keywords ??= new();
                                    modifiedArmo.Keywords.Add(formkeyArmo);
                                    modifiedArmo.Keywords.Add(formKeyPatched);
                                    modifiedArmo.ArmorRating = modifiedArmo.ArmorRating * factor + offset;
                                }

                            }
                        }
                        catch { }
                    

                    


                }
            }
            if (formSettings.Value.DoorsOn)
            {

                foreach (var doorr in state.LoadOrder.PriorityOrder.Door().WinningOverrides())
                {
                uint npcFromSelectedMod = 0;
                ModKey modKey = doorr.FormKey.ModKey.FileName;
                if (masterList.Count > 250 && stopBeforeLimit == false)
                {
                    stopBeforeLimit = true;
                    Console.WriteLine("Generated plugin will contain more than 250 masters.");
                    Console.WriteLine("The Reqtificator Lite will now stop patching and will save the esp.");
                    Console.WriteLine("To continue patching, copy this message somewhere you can read it and follow the steps below:");
                    Console.WriteLine("1. Close Synthesis");
                    Console.WriteLine("2. In your load order, enable the plugin that was just generated.");
                    Console.WriteLine("3. Start Synthesis");
                    Console.WriteLine("4. In synthesis, create a new group with a difffernt name and add a copy of the unofficialReqtificatorLite to the new group.");
                    Console.WriteLine("5. Run the Reqtificator Lite in this new synthesis group.");
                    Console.WriteLine("6. The Reqtificator Lite will start where it left off and continue to patch all records.");
                }
                if (stopBeforeLimit == true)
                {
                    continue;
                }
                if (formSettings.Value.ReqOn)
                    {npcFromSelectedMod = 1;
                    if (modKey == "Requiem for the Indifferent.esp")
                    {
                        continue;
                    }
                    bool npcInRFTI = false;
                    for (int i = 0; i < masters?.Count; i++)
                    {
                        if (modKey == masters?[i].Master.FileName)

                        {
                            npcInRFTI = true;
                        }
                    }
                    if (npcInRFTI == true)
                    {
                        continue;
                    }
                }
                    else
                    {
                        //if mod is not matched then skip
                       
                        foreach (var slectedPlugin in npcGroups.Select(x => x.ModKey.FileName))

                            if (modKey == slectedPlugin)
                                npcFromSelectedMod = 1;

                     
                    }
                if (npcFromSelectedMod == 0)
                {
                    continue;
                }
                bool lockpickingScriptBound = doorr.VirtualMachineAdapter?.Scripts.Any(s => s.Name == lockPickingControScript.Name) ?? false; 
                if (lockpickingScriptBound) {
                    continue; }

                if (!masterList.Contains(modKey.ToString()))
                {
                    masterList.Add(modKey.ToString());
                }
                var modifiedDoorr = state.PatchMod.Doors.GetOrAddAsOverride(doorr);
                        modifiedDoorr.VirtualMachineAdapter ??= new VirtualMachineAdapter();
                        modifiedDoorr.VirtualMachineAdapter.Scripts.Add(lockPickingControScript);
                




                }

            }
            if (formSettings.Value.ContOn)
            {
                foreach (var contt in state.LoadOrder.PriorityOrder.Container().WinningOverrides())
                {
                uint npcFromSelectedMod = 0;
                ModKey modKey = contt.FormKey.ModKey.FileName;
                if (masterList.Count > 250 && stopBeforeLimit == false)
                {
                    stopBeforeLimit = true;
                    Console.WriteLine("Generated plugin will contain more than 250 masters.");
                    Console.WriteLine("The Reqtificator Lite will now stop patching and will save the esp.");
                    Console.WriteLine("To continue patching, copy this message somewhere you can read it and follow the steps below:");
                    Console.WriteLine("1. Close Synthesis");
                    Console.WriteLine("2. In your load order, enable the plugin that was just generated.");
                    Console.WriteLine("3. Start Synthesis");
                    Console.WriteLine("4. In synthesis, create a new group with a difffernt name and add a copy of the unofficialReqtificatorLite to the new group.");
                    Console.WriteLine("5. Run the Reqtificator Lite in this new synthesis group.");
                    Console.WriteLine("6. The Reqtificator Lite will start where it left off and continue to patch all records.");
                }
                if (stopBeforeLimit == true)
                {
                    continue;
                }
                if (formSettings.Value.ReqOn)
                    {npcFromSelectedMod = 1;
                    if (modKey == "Requiem for the Indifferent.esp")
                    {
                        continue;
                    }
                    bool npcInRFTI = false;
                    for (int i = 0; i < masters?.Count; i++)
                    {
                        if (modKey == masters?[i].Master.FileName)

                        {
                            npcInRFTI = true;
                        }
                    }
                    if (npcInRFTI == true)
                    {
                        continue;
                    }
                }
                    else
                    {
                        //if mod is not matched then skip
                        
                        foreach (var slectedPlugin in npcGroups.Select(x => x.ModKey.FileName))

                            if (modKey == slectedPlugin)
                                npcFromSelectedMod = 1;

                       
                    }
                if (npcFromSelectedMod == 0)
                {
                    continue;
                }

                bool lockpickingScriptBound = contt.VirtualMachineAdapter?.Scripts.Any(s => s.Name == lockPickingControScript.Name) ?? false;
                if (lockpickingScriptBound)
                {
                    continue;
                }
                if (!masterList.Contains(modKey.ToString()))
                {
                    masterList.Add(modKey.ToString());
                }
                var modifiedContt = state.PatchMod.Containers.GetOrAddAsOverride(contt);
                        modifiedContt.VirtualMachineAdapter ??= new VirtualMachineAdapter();
                        modifiedContt.VirtualMachineAdapter.Scripts.Add(lockPickingControScript);
                    
                   
                }

            }
        
      









    }
}
